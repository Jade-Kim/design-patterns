{"moduleFile":{"sourceFilePath":"/Users/jadekim/Projects/Practice/design-patterns/src/global/app.ts","jsFilePath":"/Users/jadekim/Projects/Practice/design-patterns/src/global/app.js","cmps":[],"coreRuntimeApis":[],"collectionName":null,"dtsFilePath":null,"excludeFromCollection":false,"externalImports":[],"hasVdomAttribute":false,"hasVdomXlink":false,"hasVdomClass":false,"hasVdomFunctional":false,"hasVdomKey":false,"hasVdomListener":false,"hasVdomRef":false,"hasVdomRender":false,"hasVdomStyle":false,"hasVdomText":false,"htmlAttrNames":[],"htmlTagNames":[],"isCollectionDependency":false,"isLegacy":false,"localImports":[],"originalCollectionComponentPath":null,"originalImports":[],"potentialCmpRefs":[]},"jsText":"export default async () => {\r\n    /**\r\n     * The code to be executed should be placed within a default function that is\r\n     * exported by the global script. Ensure all of the code in the global script\r\n     * is wrapped in the function() that is exported.\r\n     */\r\n};\r\n/*\r\n\n3 Design Patterns\r\n\nCreational : 여러가지 다른 object 를 만들 때\r\nStructural : object 사이의 relationships\r\nBehavioral: object 사이의 interaction 또는 communication\r\n\nHow to build reusable and extensible and maintainable software.\r\n\n\n\n1. Interface - 능력 타이틀\r\n\nA contract that specifies the capabilities that a class should provide\r\n\n 레스토랑을 운영하는데 요리사가 필요하다. 요리사가 누구인지는 상관없고 요리를 할 줄 아는 능력을 가진 요리사면 된다.\r\n\n요리사 - 인터페이스\r\nJade - 클래스\r\nFrank - 클래스\r\n\nTaxCalculator - 인터페이스\r\nTaxCalculator2019 - 클래스\r\nTaxCalculator2020 - 클래스\r\n\ninterface TaxCalculator {\r\n  calculateTax(): Number;\r\n}\r\n\nexport class TaxCalculator2019 implements TaxCalculator {\r\n  calculateTax() {\r\n    return 2019;\r\n  }\r\n\n  calculateInsurance(){\r\n    return 0;\r\n  }\r\n}\r\n\nexport class TaxCalculator2020 implements TaxCalculator {\r\n  calculateTax() {\r\n    return 2020;\r\n  }\r\n}\r\n\nexport class Main {\r\n  calculator: TaxCalculator = this.getCalculator();\r\n  \n  //this.calculator.calculateTax();\r\n\n  getCalculator(): TaxCalculator {\r\n    return new TaxCalculator2019();\r\n  }\r\n}\r\n\n\n\n2. Encapsulation - getter / setter\r\n\n:클래스 외부에서 값을 조정하지 못하도록 프로퍼티는 private 으로 설정하고 클래스 내부에서 getter / setter 를 통해 값을 조정하는 방법\r\n\npublic class Account {\r\n    private float balance;\r\n\n    public void setBalance(float balance) {\r\n            If (balance > 0) this.balance = balance;\r\n}\r\n\nPublic float getBalance() {\r\n  Return balance;\r\n  }\r\n}\r\n\nSetter: setBalance()\r\nGetter: getBalance()\r\n\n\n클래스 외부에서 balance 값을 세팅하지 못하도록 private 으로 설정한다.\r\n대신 setter 를 이용해서 balance 를 더하거나 빼는 등 조정할 수 있도록 한다.\r\nBalance 잔액을 알고 싶다면 getter 를 이용하여 값을 리턴 받을 수 있다.\r\n\n\n\n\n3. Abstraction - private method\r\n\n: Reduce complexity by hiding unnecessary details\r\n\n리모콘 내부는 굉장히 복잡하지만 외부에서 보기에 간단한 버튼만 누르면 실행이 되도록 하는 것\r\n\n\nexport class MailService {\r\n  public sendEmail(): void {\r\n    this.connect(\"connect\");\r\n    this.authenticate();\r\n    this.disconnect();\r\n  }\r\n\n  private connect(arg1: string): void {\r\n    console.log(arg1);\r\n  }\r\n\n  private disconnect(): void {\r\n\n  }\r\n\n  private authenticate(): void {\r\n\n  }\r\n}\r\n\nexport class Main {\r\n  constructor (){\r\n    var mailService = new MailService();\r\n    mailService.sendEmail();\r\n  }\r\n}\r\n\n\n\n4. Inheritance\r\n\n\n*/ \r\n"}